!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
KeyInitialize	YR_ThreadPool.h	/^        KeyInitialize(){$/;"	f	class:youren::YR_ThreadPool::KeyInitialize
KeyInitialize	YR_ThreadPool.h	/^    class KeyInitialize$/;"	c	class:youren::YR_ThreadPool
Lock	YR_Monitor.h	/^    typedef YR_LockT<YR_Monitor<T,P> > Lock;$/;"	t	class:youren::YR_Monitor
NTNOWS	YR_TimeProvider.h	10;"	d
TNOW	YR_TimeProvider.h	9;"	d
ThreadData	YR_ThreadPool.h	/^        ThreadData(){}$/;"	f	class:youren::YR_ThreadPool::ThreadData
ThreadData	YR_ThreadPool.h	/^    class ThreadData$/;"	c	class:youren::YR_ThreadPool
ThreadWorker	YR_ThreadPool.h	/^        ThreadWorker(YR_ThreadPool *tpool)$/;"	f	class:youren::YR_ThreadPool::ThreadWorker
ThreadWorker	YR_ThreadPool.h	/^    class ThreadWorker : public YR_Thread$/;"	c	class:youren::YR_ThreadPool
TryLock	YR_Monitor.h	/^    typedef YR_TryLock<YR_Monitor<T,P> > TryLock;$/;"	t	class:youren::YR_Monitor
YR_Atomic	YR_Atomic.h	/^    YR_Atomic(atomic_type at =0) { set(at); }$/;"	f	class:youren::YR_Atomic
YR_Atomic	YR_Atomic.h	/^class YR_Atomic$/;"	c	namespace:youren
YR_AutoPtr	YR_AutoPtr.h	/^    YR_AutoPtr(T* p = 0) {$/;"	f	class:youren::YR_AutoPtr
YR_AutoPtr	YR_AutoPtr.h	/^    YR_AutoPtr(const YR_AutoPtr& t)$/;"	f	class:youren::YR_AutoPtr
YR_AutoPtr	YR_AutoPtr.h	/^    YR_AutoPtr(const YR_AutoPtr<Y>& t)$/;"	f	class:youren::YR_AutoPtr
YR_AutoPtr	YR_AutoPtr.h	/^class YR_AutoPtr$/;"	c	namespace:youren
YR_AutoPtrNull_Exception	YR_AutoPtr.h	/^    YR_AutoPtrNull_Exception(const string& buffer) : YR_Exception(buffer){}$/;"	f	struct:youren::YR_AutoPtrNull_Exception
YR_AutoPtrNull_Exception	YR_AutoPtr.h	/^struct YR_AutoPtrNull_Exception : public YR_Exception$/;"	s	namespace:youren
YR_Common	YR_Common.h	/^class YR_Common$/;"	c	namespace:youren
YR_EmptyMutex	YR_Lock.h	/^class YR_EmptyMutex$/;"	c	namespace:youren
YR_Exception	YR_Exception.cpp	/^YR_Exception::YR_Exception(const string& buffer)$/;"	f	class:youren::YR_Exception
YR_Exception	YR_Exception.cpp	/^YR_Exception::YR_Exception(const string& buffer, int err)$/;"	f	class:youren::YR_Exception
YR_Exception	YR_Exception.h	/^class YR_Exception : public exception$/;"	c	namespace:youren
YR_HandleBase	YR_AutoPtr.h	/^typedef YR_HandleBaseT<YR_Atomic> YR_HandleBase;$/;"	t	namespace:youren
YR_HandleBaseT	YR_AutoPtr.h	/^    YR_HandleBaseT():_atomic(0), _bNoDelete(false){}$/;"	f	class:youren::YR_HandleBaseT
YR_HandleBaseT	YR_AutoPtr.h	/^    YR_HandleBaseT(const YR_HandleBaseT&) :_atomic(0),_bNoDelete(false){}$/;"	f	class:youren::YR_HandleBaseT
YR_HandleBaseT	YR_AutoPtr.h	/^class YR_HandleBaseT$/;"	c	namespace:youren
YR_LOCK	YR_Atomic.h	9;"	d
YR_LockT	YR_Lock.h	/^    YR_LockT(const T& mutex) : _mutex(mutex) { _mutex.lock(); _acquired = true;}$/;"	f	class:youren::YR_LockT
YR_LockT	YR_Lock.h	/^    YR_LockT(const T& mutex, bool) : _mutex(mutex)$/;"	f	class:youren::YR_LockT
YR_LockT	YR_Lock.h	/^class YR_LockT$/;"	c	namespace:youren
YR_Lock_Exception	YR_Lock.h	/^    YR_Lock_Exception(const string& buffer) : YR_Exception(buffer) {  }$/;"	f	struct:youren::YR_Lock_Exception
YR_Lock_Exception	YR_Lock.h	/^    YR_Lock_Exception(const string& buffer, int err) : YR_Exception(buffer, err) {  }$/;"	f	struct:youren::YR_Lock_Exception
YR_Lock_Exception	YR_Lock.h	/^struct YR_Lock_Exception : YR_Exception$/;"	s	namespace:youren
YR_Monitor	YR_Monitor.h	/^    YR_Monitor() : _nnotify(0) {}$/;"	f	class:youren::YR_Monitor
YR_Monitor	YR_Monitor.h	/^class YR_Monitor$/;"	c	namespace:youren
YR_RW_RLockT	YR_Lock.h	/^    YR_RW_RLockT(T& lock)$/;"	f	class:youren::YR_RW_RLockT
YR_RW_RLockT	YR_Lock.h	/^class YR_RW_RLockT$/;"	c	namespace:youren
YR_RW_WLockT	YR_Lock.h	/^    YR_RW_WLockT(T& lock)$/;"	f	class:youren::YR_RW_WLockT
YR_RW_WLockT	YR_Lock.h	/^class YR_RW_WLockT$/;"	c	namespace:youren
YR_Runable	YR_Thread.h	/^class YR_Runable$/;"	c	namespace:youren
YR_Thread	YR_Thread.cpp	/^YR_Thread::YR_Thread()$/;"	f	class:youren::YR_Thread
YR_Thread	YR_Thread.h	/^class YR_Thread : YR_Runable$/;"	c	namespace:youren
YR_ThreadCond	YR_ThreadCond.cpp	/^YR_ThreadCond::YR_ThreadCond()$/;"	f	class:youren::YR_ThreadCond
YR_ThreadCond	YR_ThreadCond.h	/^class YR_ThreadCond$/;"	c	namespace:youren
YR_ThreadCond_Exception	YR_ThreadCond.h	/^    YR_ThreadCond_Exception(const string& buffer) : YR_Exception(buffer){}$/;"	f	struct:youren::YR_ThreadCond_Exception
YR_ThreadCond_Exception	YR_ThreadCond.h	/^    YR_ThreadCond_Exception(const string& buffer, int err) : YR_Exception(buffer, err){}$/;"	f	struct:youren::YR_ThreadCond_Exception
YR_ThreadCond_Exception	YR_ThreadCond.h	/^struct YR_ThreadCond_Exception : public YR_Exception$/;"	s	namespace:youren
YR_ThreadControl	YR_Thread.cpp	/^YR_ThreadControl::YR_ThreadControl()$/;"	f	class:youren::YR_ThreadControl
YR_ThreadControl	YR_Thread.cpp	/^YR_ThreadControl::YR_ThreadControl(pthread_t thread)$/;"	f	class:youren::YR_ThreadControl
YR_ThreadControl	YR_Thread.h	/^class YR_ThreadControl$/;"	c	namespace:youren
YR_ThreadControl_Exception	YR_Thread.h	/^    YR_ThreadControl_Exception(const string& buffer) : YR_Exception(buffer){}$/;"	f	struct:youren::YR_ThreadControl_Exception
YR_ThreadControl_Exception	YR_Thread.h	/^    YR_ThreadControl_Exception(const string& buffer, int err) : YR_Exception(buffer, err){}$/;"	f	struct:youren::YR_ThreadControl_Exception
YR_ThreadControl_Exception	YR_Thread.h	/^struct YR_ThreadControl_Exception : YR_Exception$/;"	s	namespace:youren
YR_ThreadLock	YR_Monitor.h	/^typedef YR_Monitor<YR_ThreadMutex,YR_ThreadCond> YR_ThreadLock;$/;"	t	namespace:youren
YR_ThreadMutex	YR_ThreadMutex.cpp	/^YR_ThreadMutex::YR_ThreadMutex()$/;"	f	class:youren::YR_ThreadMutex
YR_ThreadMutex	YR_ThreadMutex.h	/^class YR_ThreadMutex$/;"	c	namespace:youren
YR_ThreadMutex_Exception	YR_ThreadMutex.h	/^    YR_ThreadMutex_Exception(const string& buffer) : YR_Lock_Exception(buffer){}$/;"	f	struct:youren::YR_ThreadMutex_Exception
YR_ThreadMutex_Exception	YR_ThreadMutex.h	/^    YR_ThreadMutex_Exception(const string& buffer,int err) : YR_Lock_Exception(buffer, err){  }$/;"	f	struct:youren::YR_ThreadMutex_Exception
YR_ThreadMutex_Exception	YR_ThreadMutex.h	/^struct YR_ThreadMutex_Exception : public YR_Lock_Exception$/;"	s	namespace:youren
YR_ThreadPool	YR_ThreadPool.cpp	/^YR_ThreadPool::YR_ThreadPool()$/;"	f	class:youren::YR_ThreadPool
YR_ThreadPool	YR_ThreadPool.h	/^class YR_ThreadPool : public YR_ThreadLock$/;"	c	namespace:youren
YR_ThreadPool_Exception	YR_ThreadPool.h	/^    YR_ThreadPool_Exception(const string& buffer) :YR_Exception(buffer){}$/;"	f	struct:youren::YR_ThreadPool_Exception
YR_ThreadPool_Exception	YR_ThreadPool.h	/^    YR_ThreadPool_Exception(const string& buffer, int err) : YR_Exception(buffer, err){  }$/;"	f	struct:youren::YR_ThreadPool_Exception
YR_ThreadPool_Exception	YR_ThreadPool.h	/^struct YR_ThreadPool_Exception : public YR_Exception$/;"	s	namespace:youren
YR_ThreadRecLock	YR_Monitor.h	/^typedef YR_Monitor<YR_ThreadRecMutex, YR_ThreadCond> YR_ThreadRecLock;$/;"	t	namespace:youren
YR_ThreadRecMutex	YR_ThreadMutex.cpp	/^YR_ThreadRecMutex::YR_ThreadRecMutex()$/;"	f	class:youren::YR_ThreadRecMutex
YR_ThreadRecMutex	YR_ThreadMutex.h	/^class YR_ThreadRecMutex$/;"	c	namespace:youren
YR_Thread_Queue	YR_Thread_Queue.h	/^    YR_Thread_Queue():_size(0) {}$/;"	f	class:youren::YR_Thread_Queue
YR_Thread_Queue	YR_Thread_Queue.h	/^class YR_Thread_Queue : protected YR_ThreadLock$/;"	c	namespace:youren
YR_TimeProvider	YR_TimeProvider.h	/^    YR_TimeProvider() : _terminate(false),_use_tsc(true), _cpu_cycle(0),_buf_idx(0){$/;"	f	class:youren::YR_TimeProvider
YR_TimeProvider	YR_TimeProvider.h	/^class YR_TimeProvider : public YR_Thread, public YR_HandleBase$/;"	c	namespace:youren
YR_TimeProviderPtr	YR_TimeProvider.h	/^    typedef YR_AutoPtr<YR_TimeProvider> YR_TimeProviderPtr;$/;"	t	class:youren::YR_TimeProvider
YR_TryLock	YR_Lock.h	/^    YR_TryLock(const T& mutex) : YR_LockT<T>(mutex, true){}$/;"	f	class:youren::YR_TryLock
YR_TryLock	YR_Lock.h	/^class YR_TryLock : public YR_LockT<T>$/;"	c	namespace:youren
_acquired	YR_Lock.h	/^    mutable bool _acquired;$/;"	m	class:youren::YR_LockT
_acquired	YR_Lock.h	/^    mutable bool _acquired;$/;"	m	class:youren::YR_RW_RLockT
_acquired	YR_Lock.h	/^    mutable bool _acquired;$/;"	m	class:youren::YR_RW_WLockT
_atomic	YR_AutoPtr.h	/^    atomic_type _atomic;$/;"	m	class:youren::YR_HandleBaseT
_bAllDone	YR_ThreadPool.h	/^    bool _bAllDone;$/;"	m	class:youren::YR_ThreadPool
_bNoDelete	YR_AutoPtr.h	/^    bool _bNoDelete;$/;"	m	class:youren::YR_HandleBaseT
_bTerminate	YR_ThreadPool.h	/^        bool _bTerminate;$/;"	m	class:youren::YR_ThreadPool::ThreadWorker
_buf_idx	YR_TimeProvider.h	/^    volatile int _buf_idx;$/;"	m	class:youren::YR_TimeProvider
_buffer	YR_Exception.h	/^    string _buffer;$/;"	m	class:youren::YR_Exception
_busthread	YR_ThreadPool.h	/^    std::set<ThreadWorker*> _busthread;$/;"	m	class:youren::YR_ThreadPool
_code	YR_Exception.h	/^    int _code;$/;"	m	class:youren::YR_Exception
_cond	YR_Monitor.h	/^    mutable P _cond;$/;"	m	class:youren::YR_Monitor
_cond	YR_ThreadCond.h	/^    mutable pthread_cond_t _cond;$/;"	m	class:youren::YR_ThreadCond
_count	YR_ThreadMutex.h	/^    mutable int _count;$/;"	m	class:youren::YR_ThreadRecMutex
_cpu_cycle	YR_TimeProvider.h	/^    float _cpu_cycle;$/;"	m	class:youren::YR_TimeProvider
_jobqueue	YR_ThreadPool.h	/^    YR_Thread_Queue<std::function<void()>> _jobqueue;$/;"	m	class:youren::YR_ThreadPool
_jobthread	YR_ThreadPool.h	/^    std::vector<ThreadWorker*> _jobthread;$/;"	m	class:youren::YR_ThreadPool
_lock	YR_Thread.h	/^    YR_ThreadLock _lock;$/;"	m	class:youren::YR_Thread
_mutex	YR_Lock.h	/^    const T& _mutex;$/;"	m	class:youren::YR_LockT
_mutex	YR_Monitor.h	/^    T _mutex;$/;"	m	class:youren::YR_Monitor
_mutex	YR_ThreadMutex.h	/^    mutable pthread_mutex_t _mutex;$/;"	m	class:youren::YR_ThreadMutex
_mutex	YR_ThreadMutex.h	/^    mutable pthread_mutex_t _mutex;$/;"	m	class:youren::YR_ThreadRecMutex
_nnotify	YR_Monitor.h	/^    mutable int _nnotify;$/;"	m	class:youren::YR_Monitor
_ptr	YR_AutoPtr.h	/^    T* _ptr;$/;"	m	class:youren::YR_AutoPtr
_queue	YR_Thread_Queue.h	/^    queue_type _queue;$/;"	m	class:youren::YR_Thread_Queue
_running	YR_Thread.h	/^    bool _running;$/;"	m	class:youren::YR_Thread
_rwLock	YR_Lock.h	/^    const T& _rwLock;$/;"	m	class:youren::YR_RW_RLockT
_rwLock	YR_Lock.h	/^    const T& _rwLock;$/;"	m	class:youren::YR_RW_WLockT
_size	YR_Thread_Queue.h	/^    size_t _size;$/;"	m	class:youren::YR_Thread_Queue
_startqueue	YR_ThreadPool.h	/^    YR_Thread_Queue<std::function<void()>> _startqueue;$/;"	m	class:youren::YR_ThreadPool
_t	YR_TimeProvider.h	/^    timeval _t[2];$/;"	m	class:youren::YR_TimeProvider
_terminate	YR_TimeProvider.h	/^    bool _terminate;$/;"	m	class:youren::YR_TimeProvider
_thread	YR_Thread.h	/^    pthread_t _thread;$/;"	m	class:youren::YR_ThreadControl
_tid	YR_Thread.h	/^    pthread_t _tid;$/;"	m	class:youren::YR_Thread
_tmutex	YR_ThreadPool.h	/^    YR_ThreadLock _tmutex;$/;"	m	class:youren::YR_ThreadPool
_tpool	YR_ThreadPool.h	/^        YR_ThreadPool *_tpool;$/;"	m	class:youren::YR_ThreadPool::ThreadWorker
_tsc	YR_TimeProvider.h	/^    uint64_t _tsc[2];$/;"	m	class:youren::YR_TimeProvider
_use_tsc	YR_TimeProvider.h	/^    bool _use_tsc;$/;"	m	class:youren::YR_TimeProvider
_value	YR_Atomic.h	/^    youren_atomic_t _value;$/;"	m	class:youren::YR_Atomic
abstime	YR_ThreadCond.cpp	/^timespec YR_ThreadCond::abstime( int millsecond) const$/;"	f	class:youren::YR_ThreadCond
acquire	YR_Lock.h	/^    void acquire() const $/;"	f	class:youren::YR_LockT
acquired	YR_Lock.h	/^    bool acquired() const$/;"	f	class:youren::YR_LockT
add	YR_Atomic.h	/^    atomic_type add(atomic_type i) { return add_and_return(i); }$/;"	f	class:youren::YR_Atomic
addTimeOffset	YR_TimeProvider.cpp	/^void YR_TimeProvider::addTimeOffset(timeval& tt, const int &idx)$/;"	f	class:youren::YR_TimeProvider
add_and_return	YR_Atomic.h	/^    int add_and_return(int i)$/;"	f	class:youren::YR_Atomic
atomic_type	YR_Atomic.h	/^    typedef int atomic_type;$/;"	t	class:youren::YR_Atomic
atomic_type	YR_AutoPtr.h	/^    typedef T atomic_type;$/;"	t	class:youren::YR_HandleBaseT
broadcast	YR_ThreadCond.cpp	/^void YR_ThreadCond::broadcast()$/;"	f	class:youren::YR_ThreadCond
clear	YR_ThreadPool.cpp	/^void YR_ThreadPool::clear()$/;"	f	class:youren::YR_ThreadPool
clear	YR_Thread_Queue.h	/^template<typename T, typename D> void YR_Thread_Queue<T, D>::clear()$/;"	f	class:youren::YR_Thread_Queue
count	YR_ThreadMutex.cpp	/^int YR_ThreadMutex::count() const$/;"	f	class:youren::YR_ThreadMutex
count	YR_ThreadMutex.cpp	/^int YR_ThreadRecMutex::count() const$/;"	f	class:youren::YR_ThreadRecMutex
count	YR_ThreadMutex.cpp	/^void YR_ThreadMutex::count(int c) const$/;"	f	class:youren::YR_ThreadMutex
count	YR_ThreadMutex.cpp	/^void YR_ThreadRecMutex::count(int c) const$/;"	f	class:youren::YR_ThreadRecMutex
counter	YR_Atomic.h	/^    typedef struct { volatile int counter; } youren_atomic_t;$/;"	m	struct:youren::__anon1
cpuMHz	YR_TimeProvider.cpp	/^float YR_TimeProvider::cpuMHz()$/;"	f	class:youren::YR_TimeProvider
dec	YR_Atomic.h	/^    atomic_type dec() { return sub(1); }$/;"	f	class:youren::YR_Atomic
decRef	YR_AutoPtr.h	/^    void decRef()$/;"	f	class:youren::YR_HandleBaseT
decRef	YR_AutoPtr.h	/^inline void YR_HandleBaseT<int>::decRef()$/;"	f	class:youren::YR_HandleBaseT
dec_and_test	YR_Atomic.h	/^    bool dec_and_test()$/;"	f	class:youren::YR_Atomic
destructor	YR_ThreadPool.cpp	/^void YR_ThreadPool::destructor(void *p)$/;"	f	class:youren::YR_ThreadPool
detach	YR_Thread.cpp	/^void YR_ThreadControl::detach()$/;"	f	class:youren::YR_ThreadControl
dynamicCast	YR_AutoPtr.h	/^    static YR_AutoPtr dynamicCast(Y* p)$/;"	f	class:youren::YR_AutoPtr
dynamicCast	YR_AutoPtr.h	/^    static YR_AutoPtr dynamicCast(const YR_AutoPtr<Y> & r)$/;"	f	class:youren::YR_AutoPtr
element_type	YR_AutoPtr.h	/^    typedef T element_type;$/;"	t	class:youren::YR_AutoPtr
empty	YR_Thread_Queue.h	/^template<typename T, typename D> bool YR_Thread_Queue<T, D>::empty() const$/;"	f	class:youren::YR_Thread_Queue
exec	YR_ThreadPool.h	/^    void exec(std::function<void()> tf)$/;"	f	class:youren::YR_ThreadPool
exit	YR_ThreadPool.cpp	/^void YR_ThreadPool::exit()$/;"	f	class:youren::YR_ThreadPool
finish	YR_ThreadPool.cpp	/^bool YR_ThreadPool::finish()$/;"	f	class:youren::YR_ThreadPool
g_key	YR_ThreadPool.cpp	/^pthread_key_t YR_ThreadPool::g_key;$/;"	m	class:youren::YR_ThreadPool	file:
g_key	YR_ThreadPool.h	/^    static pthread_key_t g_key;$/;"	m	class:youren::YR_ThreadPool
g_key_initialize	YR_ThreadPool.cpp	/^YR_ThreadPool::KeyInitialize YR_ThreadPool::g_key_initialize;$/;"	m	class:youren::YR_ThreadPool	file:
g_key_initialize	YR_ThreadPool.h	/^    static KeyInitialize g_key_initialize;$/;"	m	class:youren::YR_ThreadPool
g_tl	YR_TimeProvider.cpp	/^YR_ThreadLock YR_TimeProvider::g_tl;$/;"	m	class:youren::YR_TimeProvider	file:
g_tl	YR_TimeProvider.h	/^    static YR_ThreadLock g_tl;$/;"	m	class:youren::YR_TimeProvider
g_tp	YR_TimeProvider.cpp	/^YR_TimeProvider::YR_TimeProviderPtr YR_TimeProvider::g_tp = NULL;$/;"	m	class:youren::YR_TimeProvider	file:
g_tp	YR_TimeProvider.h	/^    static YR_TimeProviderPtr g_tp;$/;"	m	class:youren::YR_TimeProvider
get	YR_Atomic.h	/^    atomic_type get() const { return _value.counter; }$/;"	f	class:youren::YR_Atomic
get	YR_AutoPtr.h	/^    T* get() const$/;"	f	class:youren::YR_AutoPtr
get	YR_ThreadPool.cpp	/^std::function<void()> YR_ThreadPool::get()$/;"	f	class:youren::YR_ThreadPool
get	YR_ThreadPool.cpp	/^std::function<void()> YR_ThreadPool::get(ThreadWorker* ptw)$/;"	f	class:youren::YR_ThreadPool
getBacktrace	YR_Exception.cpp	/^void YR_Exception::getBacktrace() throw()$/;"	f	class:youren::YR_Exception
getErrorCode	YR_Exception.cpp	/^int YR_Exception::getErrorCode()$/;"	f	class:youren::YR_Exception
getInstance	YR_TimeProvider.cpp	/^YR_TimeProvider* YR_TimeProvider::getInstance()$/;"	f	class:youren::YR_TimeProvider
getJobNum	YR_ThreadPool.h	/^    size_t getJobNum() { return _jobqueue.size(); }$/;"	f	class:youren::YR_ThreadPool
getNow	YR_TimeProvider.cpp	/^void YR_TimeProvider::getNow(timeval * tv)$/;"	f	class:youren::YR_TimeProvider
getNow	YR_TimeProvider.h	/^    time_t getNow() { return _t[_buf_idx].tv_sec; }$/;"	f	class:youren::YR_TimeProvider
getNowMs	YR_TimeProvider.cpp	/^int64_t YR_TimeProvider::getNowMs()$/;"	f	class:youren::YR_TimeProvider
getRef	YR_AutoPtr.h	/^    int getRef() const { return _atomic.get(); }$/;"	f	class:youren::YR_HandleBaseT
getRef	YR_AutoPtr.h	/^inline int YR_HandleBaseT<int>::getRef() const$/;"	f	class:youren::YR_HandleBaseT
getThreadControl	YR_Thread.cpp	/^YR_ThreadControl YR_Thread::getThreadControl() const$/;"	f	class:youren::YR_Thread
getThreadData	YR_ThreadPool.cpp	/^YR_ThreadPool::ThreadData* YR_ThreadPool::getThreadData()$/;"	f	class:youren::YR_ThreadPool
getThreadData	YR_ThreadPool.cpp	/^YR_ThreadPool::ThreadData* YR_ThreadPool::getThreadData(pthread_key_t pkey)$/;"	f	class:youren::YR_ThreadPool
getThreadNum	YR_ThreadPool.h	/^    size_t getThreadNum() { Lock lock(*this); return _jobthread.size(); }$/;"	f	class:youren::YR_ThreadPool
id	YR_Thread.cpp	/^pthread_t YR_ThreadControl::id() const$/;"	f	class:youren::YR_ThreadControl
id	YR_Thread.h	/^    pthread_t id() { return _tid; }$/;"	f	class:youren::YR_Thread
idle	YR_ThreadPool.cpp	/^void YR_ThreadPool::idle(ThreadWorker* ptw)$/;"	f	class:youren::YR_ThreadPool
inc	YR_Atomic.h	/^    atomic_type inc() { return add(1); }$/;"	f	class:youren::YR_Atomic
incRef	YR_AutoPtr.h	/^    void incRef() {_atomic.inc_fast();}$/;"	f	class:youren::YR_HandleBaseT
incRef	YR_AutoPtr.h	/^inline void YR_HandleBaseT<int>::incRef()$/;"	f	class:youren::YR_HandleBaseT
inc_fast	YR_Atomic.h	/^    void inc_fast()$/;"	f	class:youren::YR_Atomic
init	YR_ThreadPool.cpp	/^void YR_ThreadPool::init(size_t num)$/;"	f	class:youren::YR_ThreadPool
isAlive	YR_Thread.cpp	/^bool YR_Thread::isAlive() const $/;"	f	class:youren::YR_Thread
isdigit	YR_Common.cpp	/^bool YR_Common::isdigit(const string &sInput)$/;"	f	class:youren::YR_Common
join	YR_Thread.cpp	/^void YR_ThreadControl::join()$/;"	f	class:youren::YR_ThreadControl
lock	YR_Lock.h	/^    int lock() const { return 0; }$/;"	f	class:youren::YR_EmptyMutex
lock	YR_Monitor.h	/^    void lock() const$/;"	f	class:youren::YR_Monitor
lock	YR_ThreadMutex.cpp	/^int YR_ThreadRecMutex::lock() const$/;"	f	class:youren::YR_ThreadRecMutex
lock	YR_ThreadMutex.cpp	/^void YR_ThreadMutex::lock() const$/;"	f	class:youren::YR_ThreadMutex
lower	YR_Common.cpp	/^string YR_Common::lower(const string &s)$/;"	f	class:youren::YR_Common
makeThreadData	YR_ThreadPool.h	/^        static T* makeThreadData()$/;"	f	class:youren::YR_ThreadPool::ThreadData
notify	YR_Monitor.h	/^    void notify()$/;"	f	class:youren::YR_Monitor
notifyAll	YR_Monitor.h	/^    void notifyAll()$/;"	f	class:youren::YR_Monitor
notifyImpl	YR_Monitor.h	/^    void notifyImpl(int nnotify) const$/;"	f	class:youren::YR_Monitor
notifyT	YR_ThreadPool.cpp	/^void YR_ThreadPool::notifyT()$/;"	f	class:youren::YR_ThreadPool
notifyT	YR_Thread_Queue.h	/^template<typename T, typename D> void YR_Thread_Queue<T, D>::notifyT()$/;"	f	class:youren::YR_Thread_Queue
nowToms	YR_Common.cpp	/^int64_t YR_Common::nowToms()$/;"	f	class:youren::YR_Common
nowTostr	YR_Common.cpp	/^string YR_Common::nowTostr(const string &sFormat)$/;"	f	class:youren::YR_Common
nowTous	YR_Common.cpp	/^int64_t YR_Common::nowTous()$/;"	f	class:youren::YR_Common
operator !=	YR_AutoPtr.h	/^operator!=(const YR_AutoPtr<T>& lhs, const YR_AutoPtr<U>& rhs)$/;"	f	namespace:youren
operator *	YR_AutoPtr.h	/^    T& operator*() const$/;"	f	class:youren::YR_AutoPtr
operator ++	YR_Atomic.h	/^    YR_Atomic& operator++()$/;"	f	class:youren::YR_Atomic
operator +=	YR_Atomic.h	/^    YR_Atomic& operator+=(atomic_type n)$/;"	f	class:youren::YR_Atomic
operator --	YR_Atomic.h	/^    YR_Atomic& operator--()$/;"	f	class:youren::YR_Atomic
operator -=	YR_Atomic.h	/^    YR_Atomic& operator-=(atomic_type n)$/;"	f	class:youren::YR_Atomic
operator ->	YR_AutoPtr.h	/^    T* operator->() const$/;"	f	class:youren::YR_AutoPtr
operator <	YR_AutoPtr.h	/^operator<(const YR_AutoPtr<T>& lhs,const YR_AutoPtr<U>& rhs)$/;"	f	namespace:youren
operator =	YR_Atomic.h	/^    YR_Atomic& operator=(atomic_type n)$/;"	f	class:youren::YR_Atomic
operator =	YR_AutoPtr.h	/^    YR_AutoPtr& operator=(T* p)$/;"	f	class:youren::YR_AutoPtr
operator =	YR_AutoPtr.h	/^    YR_AutoPtr& operator=(const YR_AutoPtr& r)$/;"	f	class:youren::YR_AutoPtr
operator =	YR_AutoPtr.h	/^    YR_AutoPtr& operator=(const YR_AutoPtr<Y>& r)$/;"	f	class:youren::YR_AutoPtr
operator =	YR_AutoPtr.h	/^    YR_HandleBaseT& operator=(const YR_HandleBaseT&) { return *this; }$/;"	f	class:youren::YR_HandleBaseT
operator ==	YR_AutoPtr.h	/^operator==(const YR_AutoPtr<T>& lhs, const YR_AutoPtr<U>& rhs)$/;"	f	namespace:youren
operator atomic_type	YR_Atomic.h	/^    operator atomic_type() const $/;"	f	class:youren::YR_Atomic
operator bool	YR_AutoPtr.h	/^    operator bool() const$/;"	f	class:youren::YR_AutoPtr
pop_front	YR_Thread_Queue.h	/^bool YR_Thread_Queue<T, D>::pop_front(T& t, size_t millsecond)$/;"	f	class:youren::YR_Thread_Queue
push_back	YR_Thread_Queue.h	/^template<typename T, typename D> void YR_Thread_Queue<T, D>::push_back(const T& t)$/;"	f	class:youren::YR_Thread_Queue
push_back	YR_Thread_Queue.h	/^template<typename T, typename D> void YR_Thread_Queue<T, D>::push_back(const queue_type &qt)$/;"	f	class:youren::YR_Thread_Queue
push_front	YR_Thread_Queue.h	/^template<typename T, typename D> void YR_Thread_Queue<T, D>::push_front(const T& t)$/;"	f	class:youren::YR_Thread_Queue
push_front	YR_Thread_Queue.h	/^template<typename T, typename D> void YR_Thread_Queue<T, D>::push_front(const queue_type &qt)$/;"	f	class:youren::YR_Thread_Queue
queue_type	YR_Thread_Queue.h	/^    typedef D queue_type;$/;"	t	class:youren::YR_Thread_Queue
rdtsc	YR_TimeProvider.h	7;"	d
release	YR_Lock.h	/^    void release() const$/;"	f	class:youren::YR_LockT
run	YR_ThreadPool.cpp	/^void YR_ThreadPool::ThreadWorker::run()$/;"	f	class:youren::YR_ThreadPool::ThreadWorker
run	YR_TimeProvider.cpp	/^void YR_TimeProvider::run()$/;"	f	class:youren::YR_TimeProvider
set	YR_Atomic.h	/^    atomic_type set(atomic_type i)$/;"	f	class:youren::YR_Atomic
setNoDelete	YR_AutoPtr.h	/^    void setNoDelete(bool b) { _bNoDelete = b; }$/;"	f	class:youren::YR_HandleBaseT
setThreadData	YR_ThreadPool.cpp	/^void YR_ThreadPool::setThreadData(YR_ThreadPool::ThreadData *p)$/;"	f	class:youren::YR_ThreadPool
setThreadData	YR_ThreadPool.cpp	/^void YR_ThreadPool::setThreadData(pthread_key_t pkey, ThreadData *p)$/;"	f	class:youren::YR_ThreadPool
setTsc	YR_TimeProvider.cpp	/^void YR_TimeProvider::setTsc(timeval& tt)$/;"	f	class:youren::YR_TimeProvider
signal	YR_ThreadCond.cpp	/^void YR_ThreadCond::signal()$/;"	f	class:youren::YR_ThreadCond
size	YR_Thread_Queue.h	/^template<typename T, typename D> size_t YR_Thread_Queue<T, D>::size() const$/;"	f	class:youren::YR_Thread_Queue
sleep	YR_Thread.cpp	/^void YR_ThreadControl::sleep(long millsecond) $/;"	f	class:youren::YR_ThreadControl
start	YR_Thread.cpp	/^YR_ThreadControl YR_Thread::start()$/;"	f	class:youren::YR_Thread
start	YR_ThreadPool.cpp	/^void YR_ThreadPool::start()$/;"	f	class:youren::YR_ThreadPool
start	YR_ThreadPool.h	/^    void start(std::function<void()> tf)$/;"	f	class:youren::YR_ThreadPool
stop	YR_ThreadPool.cpp	/^void YR_ThreadPool::stop()$/;"	f	class:youren::YR_ThreadPool
strTotm	YR_Common.cpp	/^int YR_Common::strTotm(const string &sString, const string &sFormat, struct tm &stTm)$/;"	f	class:youren::YR_Common
sub	YR_Atomic.h	/^    atomic_type sub(atomic_type i) { return add_and_return(-i); }$/;"	f	class:youren::YR_Atomic
swap	YR_AutoPtr.h	/^    void swap(YR_AutoPtr& other)$/;"	f	class:youren::YR_AutoPtr
swap	YR_Thread_Queue.h	/^template<typename T, typename D> bool YR_Thread_Queue<T, D>::swap(queue_type &q, size_t millsecond)$/;"	f	class:youren::YR_Thread_Queue
terminate	YR_ThreadPool.cpp	/^void YR_ThreadPool::ThreadWorker::terminate()$/;"	f	class:youren::YR_ThreadPool::ThreadWorker
threadEntry	YR_Thread.cpp	/^void YR_Thread::threadEntry(YR_Thread* pThread)$/;"	f	class:youren::YR_Thread
throwNullHandleException	YR_AutoPtr.h	/^YR_AutoPtr<T>::throwNullHandleException() const$/;"	f	class:youren::YR_AutoPtr
timeWait	YR_Monitor.h	/^    bool timeWait(int millsecond) const$/;"	f	class:youren::YR_Monitor
timeWait	YR_ThreadCond.h	/^    bool timeWait(const Mutex& mutex, int millsecond) const$/;"	f	class:youren::YR_ThreadCond
tmTostr	YR_Common.cpp	/^string YR_Common::tmTostr(const struct tm &stTm, const string &sFormat)$/;"	f	class:youren::YR_Common
tmTostr	YR_Common.cpp	/^string YR_Common::tmTostr(const time_t &t, const string &sFormat)$/;"	f	class:youren::YR_Common
trim	YR_Common.cpp	/^string YR_Common::trim(const string &sStr, const string &s, bool bChar)$/;"	f	class:youren::YR_Common
trimleft	YR_Common.cpp	/^string YR_Common::trimleft(const string &sStr, const string &s, bool bChar)$/;"	f	class:youren::YR_Common
trimright	YR_Common.cpp	/^string YR_Common::trimright(const string &sStr, const string &s, bool bChar)$/;"	f	class:youren::YR_Common
tryAcquired	YR_Lock.h	/^    bool tryAcquired() const$/;"	f	class:youren::YR_LockT
tryLock	YR_Monitor.h	/^    bool tryLock() const $/;"	f	class:youren::YR_Monitor
tryLock	YR_ThreadMutex.cpp	/^bool YR_ThreadMutex::tryLock() const$/;"	f	class:youren::YR_ThreadMutex
tryLock	YR_ThreadMutex.cpp	/^bool YR_ThreadRecMutex::tryLock() const$/;"	f	class:youren::YR_ThreadRecMutex
trylock	YR_Lock.h	/^    bool trylock() const { return true; }$/;"	f	class:youren::YR_EmptyMutex
unlock	YR_Lock.h	/^    int unlock() const { return 0; }$/;"	f	class:youren::YR_EmptyMutex
unlock	YR_Monitor.h	/^    void unlock() const$/;"	f	class:youren::YR_Monitor
unlock	YR_ThreadMutex.cpp	/^int YR_ThreadRecMutex::unlock() const$/;"	f	class:youren::YR_ThreadRecMutex
unlock	YR_ThreadMutex.cpp	/^void YR_ThreadMutex::unlock() const$/;"	f	class:youren::YR_ThreadMutex
upper	YR_Common.cpp	/^string YR_Common::upper(const string &s)$/;"	f	class:youren::YR_Common
wait	YR_Monitor.h	/^    void wait() const$/;"	f	class:youren::YR_Monitor
wait	YR_ThreadCond.h	/^    void wait(const Mutex& mutex) const$/;"	f	class:youren::YR_ThreadCond
waitForAllDone	YR_ThreadPool.cpp	/^bool YR_ThreadPool::waitForAllDone(int millsecond)$/;"	f	class:youren::YR_ThreadPool
what	YR_Exception.cpp	/^const char* YR_Exception::what() const throw()$/;"	f	class:youren::YR_Exception
willUnlock	YR_ThreadMutex.cpp	/^bool YR_ThreadRecMutex::willUnlock() const$/;"	f	class:youren::YR_ThreadRecMutex
willUnlock	YR_ThreadMutex.h	/^    bool willUnlock() const { return true; }$/;"	f	class:youren::YR_ThreadMutex
yield	YR_Thread.cpp	/^void YR_ThreadControl::yield()$/;"	f	class:youren::YR_ThreadControl
youren	YR_Atomic.h	/^namespace youren {$/;"	n
youren	YR_AutoPtr.h	/^namespace youren{$/;"	n
youren	YR_Common.cpp	/^namespace youren{$/;"	n	file:
youren	YR_Common.h	/^namespace youren{$/;"	n
youren	YR_Exception.cpp	/^namespace youren{$/;"	n	file:
youren	YR_Exception.h	/^namespace youren {$/;"	n
youren	YR_Lock.h	/^namespace youren {$/;"	n
youren	YR_Monitor.h	/^namespace youren {$/;"	n
youren	YR_Thread.cpp	/^namespace youren{$/;"	n	file:
youren	YR_Thread.h	/^namespace youren {$/;"	n
youren	YR_ThreadCond.cpp	/^namespace youren{$/;"	n	file:
youren	YR_ThreadCond.h	/^namespace youren {$/;"	n
youren	YR_ThreadMutex.cpp	/^namespace youren{$/;"	n	file:
youren	YR_ThreadMutex.h	/^namespace youren {$/;"	n
youren	YR_ThreadPool.cpp	/^namespace youren {$/;"	n	file:
youren	YR_ThreadPool.h	/^namespace youren{$/;"	n
youren	YR_Thread_Queue.h	/^namespace youren{$/;"	n
youren	YR_TimeProvider.cpp	/^namespace youren {$/;"	n	file:
youren	YR_TimeProvider.h	/^namespace youren {$/;"	n
youren_atomic_read	YR_Atomic.h	11;"	d
youren_atomic_set	YR_Atomic.h	13;"	d
youren_atomic_t	YR_Atomic.h	/^    typedef struct { volatile int counter; } youren_atomic_t;$/;"	t	namespace:youren	typeref:struct:youren::__anon1
~KeyInitialize	YR_ThreadPool.h	/^        ~KeyInitialize(){$/;"	f	class:youren::YR_ThreadPool::KeyInitialize
~ThreadData	YR_ThreadPool.h	/^        virtual ~ThreadData(){}$/;"	f	class:youren::YR_ThreadPool::ThreadData
~YR_Atomic	YR_Atomic.h	/^    ~YR_Atomic() {}$/;"	f	class:youren::YR_Atomic
~YR_AutoPtr	YR_AutoPtr.h	/^    ~YR_AutoPtr() {$/;"	f	class:youren::YR_AutoPtr
~YR_AutoPtrNull_Exception	YR_AutoPtr.h	/^    ~YR_AutoPtrNull_Exception() throw(){}$/;"	f	struct:youren::YR_AutoPtrNull_Exception
~YR_Exception	YR_Exception.h	/^    virtual ~YR_Exception() {}$/;"	f	class:youren::YR_Exception
~YR_HandleBaseT	YR_AutoPtr.h	/^    virtual ~YR_HandleBaseT(){}$/;"	f	class:youren::YR_HandleBaseT
~YR_LockT	YR_Lock.h	/^    virtual ~YR_LockT() {$/;"	f	class:youren::YR_LockT
~YR_Lock_Exception	YR_Lock.h	/^    ~YR_Lock_Exception() throw(){  }$/;"	f	struct:youren::YR_Lock_Exception
~YR_Monitor	YR_Monitor.h	/^    virtual ~YR_Monitor() {}$/;"	f	class:youren::YR_Monitor
~YR_RW_RLockT	YR_Lock.h	/^    ~YR_RW_RLockT()$/;"	f	class:youren::YR_RW_RLockT
~YR_RW_WLockT	YR_Lock.h	/^    ~YR_RW_WLockT()$/;"	f	class:youren::YR_RW_WLockT
~YR_Runable	YR_Thread.h	/^    virtual ~YR_Runable(){}$/;"	f	class:youren::YR_Runable
~YR_Thread	YR_Thread.h	/^    virtual ~YR_Thread() {}$/;"	f	class:youren::YR_Thread
~YR_ThreadCond	YR_ThreadCond.cpp	/^YR_ThreadCond::~YR_ThreadCond()$/;"	f	class:youren::YR_ThreadCond
~YR_ThreadCond_Exception	YR_ThreadCond.h	/^    ~YR_ThreadCond_Exception() throw(){}$/;"	f	struct:youren::YR_ThreadCond_Exception
~YR_ThreadControl_Exception	YR_Thread.h	/^    ~YR_ThreadControl_Exception() throw() {}$/;"	f	struct:youren::YR_ThreadControl_Exception
~YR_ThreadMutex	YR_ThreadMutex.cpp	/^YR_ThreadMutex::~YR_ThreadMutex()$/;"	f	class:youren::YR_ThreadMutex
~YR_ThreadMutex_Exception	YR_ThreadMutex.h	/^    ~YR_ThreadMutex_Exception() throw(){}$/;"	f	struct:youren::YR_ThreadMutex_Exception
~YR_ThreadPool	YR_ThreadPool.cpp	/^YR_ThreadPool::~YR_ThreadPool()$/;"	f	class:youren::YR_ThreadPool
~YR_ThreadPool_Exception	YR_ThreadPool.h	/^    ~YR_ThreadPool_Exception() throw() {}$/;"	f	struct:youren::YR_ThreadPool_Exception
~YR_ThreadRecMutex	YR_ThreadMutex.cpp	/^YR_ThreadRecMutex::~YR_ThreadRecMutex()$/;"	f	class:youren::YR_ThreadRecMutex
~YR_Thread_Queue	YR_Thread_Queue.h	/^    ~YR_Thread_Queue() {}$/;"	f	class:youren::YR_Thread_Queue
~YR_TimeProvider	YR_TimeProvider.cpp	/^YR_TimeProvider::~YR_TimeProvider()$/;"	f	class:youren::YR_TimeProvider
