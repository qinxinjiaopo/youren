!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Lock	YR_Monitor.h	/^    typedef YR_LockT<YR_Monitor<T,P> > Lock;$/;"	t	class:youren::YR_Monitor
NTNOWS	YR_TimeProvider.h	10;"	d
TNOW	YR_TimeProvider.h	9;"	d
TryLock	YR_Monitor.h	/^    typedef YR_TryLock<YR_Monitor<T,P> > TryLock;$/;"	t	class:youren::YR_Monitor
YR_Atomic	YR_Atomic.h	/^    YR_Atomic(atomic_type at =0) { set(at); }$/;"	f	class:youren::YR_Atomic
YR_Atomic	YR_Atomic.h	/^class YR_Atomic$/;"	c	namespace:youren
YR_AutoPtr	YR_AutoPtr.h	/^    YR_AutoPtr(T* p = 0) {$/;"	f	class:youren::YR_AutoPtr
YR_AutoPtr	YR_AutoPtr.h	/^    YR_AutoPtr(const YR_AutoPtr& r)$/;"	f	class:youren::YR_AutoPtr
YR_AutoPtr	YR_AutoPtr.h	/^    YR_AutoPtr(const YR_AutoPtr<Y>& r)$/;"	f	class:youren::YR_AutoPtr
YR_AutoPtr	YR_AutoPtr.h	/^class YR_AutoPtr$/;"	c	namespace:youren
YR_AutoPtrNull_Exception	YR_AutoPtr.h	/^    YR_AutoPtrNull_Exception(const string& buffer) : YR_Exception(buffer){}$/;"	f	struct:youren::YR_AutoPtrNull_Exception
YR_AutoPtrNull_Exception	YR_AutoPtr.h	/^struct YR_AutoPtrNull_Exception : public YR_Exception$/;"	s	namespace:youren
YR_EmptyMutex	YR_Lock.h	/^class YR_EmptyMutex$/;"	c	namespace:youren
YR_HandleBase	YR_AutoPtr.h	/^typedef YR_HandleBaseT<YR_Atomic> YR_HandleBase;$/;"	t	namespace:youren
YR_HandleBaseT	YR_AutoPtr.h	/^    YR_HandleBaseT():_atomic(0), _bNoDelete(false){}$/;"	f	class:youren::YR_HandleBaseT
YR_HandleBaseT	YR_AutoPtr.h	/^    YR_HandleBaseT(const YR_HandleBaseT&) :_atomic(0),_bNoDelete(false){}$/;"	f	class:youren::YR_HandleBaseT
YR_HandleBaseT	YR_AutoPtr.h	/^class YR_HandleBaseT$/;"	c	namespace:youren
YR_LOCK	YR_Atomic.h	9;"	d
YR_LockT	YR_Lock.h	/^    YR_LockT(const T& mutex) : _mutex(mutex) { _mutex.lock(); _acquired = true;}$/;"	f	class:youren::YR_LockT
YR_LockT	YR_Lock.h	/^    YR_LockT(const T& mutex, bool) : _mutex(mutex)$/;"	f	class:youren::YR_LockT
YR_LockT	YR_Lock.h	/^class YR_LockT$/;"	c	namespace:youren
YR_Lock_Exception	YR_Lock.h	/^    YR_Lock_Exception(const string& buffer) : YR_Exception(buffer) {  }$/;"	f	struct:youren::YR_Lock_Exception
YR_Lock_Exception	YR_Lock.h	/^    YR_Lock_Exception(const string& buffer, int err) : YR_Exception(buffer, err) {  }$/;"	f	struct:youren::YR_Lock_Exception
YR_Lock_Exception	YR_Lock.h	/^struct YR_Lock_Exception : YR_Exception$/;"	s	namespace:youren
YR_Monitor	YR_Monitor.h	/^    YR_Monitor() : _nnotify(0) {}$/;"	f	class:youren::YR_Monitor
YR_Monitor	YR_Monitor.h	/^class YR_Monitor$/;"	c	namespace:youren
YR_RW_RLockT	YR_Lock.h	/^    YR_RW_RLockT(T& lock)$/;"	f	class:youren::YR_RW_RLockT
YR_RW_RLockT	YR_Lock.h	/^class YR_RW_RLockT$/;"	c	namespace:youren
YR_Runable	YR_Thread.h	/^class YR_Runable$/;"	c	namespace:youren
YR_Thread	YR_Thread.cpp	/^YR_Thread::YR_Thread()$/;"	f	class:youren::YR_Thread
YR_Thread	YR_Thread.h	/^class YR_Thread : YR_Runable$/;"	c	namespace:youren
YR_ThreadCond	YR_ThreadCond.h	/^    YR_ThreadCond() {}$/;"	f	class:youren::YR_ThreadCond
YR_ThreadCond	YR_ThreadCond.h	/^class YR_ThreadCond$/;"	c	namespace:youren
YR_ThreadCond_Exception	YR_ThreadCond.h	/^    YR_ThreadCond_Exception(const string& buffer) : YR_Exception(buffer){}$/;"	f	struct:youren::YR_ThreadCond_Exception
YR_ThreadCond_Exception	YR_ThreadCond.h	/^    YR_ThreadCond_Exception(const string& buffer, int err) : YR_Exception(buffer, err){}$/;"	f	struct:youren::YR_ThreadCond_Exception
YR_ThreadCond_Exception	YR_ThreadCond.h	/^struct YR_ThreadCond_Exception : public YR_Exception$/;"	s	namespace:youren
YR_ThreadControl	YR_Thread.cpp	/^YR_ThreadControl::YR_ThreadControl()$/;"	f	class:youren::YR_ThreadControl
YR_ThreadControl	YR_Thread.cpp	/^YR_ThreadControl::YR_ThreadControl(pthread_t thread)$/;"	f	class:youren::YR_ThreadControl
YR_ThreadControl	YR_Thread.h	/^class YR_ThreadControl$/;"	c	namespace:youren
YR_ThreadControl_Exception	YR_Thread.h	/^    YR_ThreadControl_Exception(const string& buffer) : YR_Exception(buffer){}$/;"	f	struct:youren::YR_ThreadControl_Exception
YR_ThreadControl_Exception	YR_Thread.h	/^    YR_ThreadControl_Exception(const string& buffer, int err) : YR_Exception(buffer, err){}$/;"	f	struct:youren::YR_ThreadControl_Exception
YR_ThreadControl_Exception	YR_Thread.h	/^struct YR_ThreadControl_Exception : YR_Exception$/;"	s	namespace:youren
YR_ThreadLock	YR_Monitor.h	/^typedef YR_Monitor<YR_ThreadMutex,YR_ThreadCond> YR_ThreadLock;$/;"	t	namespace:youren
YR_ThreadMutex	YR_ThreadMutex.cpp	/^YR_ThreadMutex::YR_ThreadMutex()$/;"	f	class:youren::YR_ThreadMutex
YR_ThreadMutex	YR_ThreadMutex.h	/^    YR_ThreadMutex() {}$/;"	f	class:youren::YR_ThreadMutex
YR_ThreadMutex	YR_ThreadMutex.h	/^class YR_ThreadMutex$/;"	c	namespace:youren
YR_ThreadMutex_Exception	YR_ThreadMutex.h	/^    YR_ThreadMutex_Exception(const string& buffer) : YR_Lock_Exception(buffer){}$/;"	f	struct:youren::YR_ThreadMutex_Exception
YR_ThreadMutex_Exception	YR_ThreadMutex.h	/^    YR_ThreadMutex_Exception(const string& buffer,int err) : YR_Lock_Exception(buffer, err){  }$/;"	f	struct:youren::YR_ThreadMutex_Exception
YR_ThreadMutex_Exception	YR_ThreadMutex.h	/^struct YR_ThreadMutex_Exception : public YR_Lock_Exception$/;"	s	namespace:youren
YR_ThreadRecLock	YR_Monitor.h	/^typedef YR_Monitor<YR_ThreadRecMutex, YR_ThreadCond> YR_ThreadRecLock;$/;"	t	namespace:youren
YR_ThreadRecMutex	YR_ThreadMutex.cpp	/^YR_ThreadRecMutex::YR_ThreadRecMutex()$/;"	f	class:youren::YR_ThreadRecMutex
YR_ThreadRecMutex	YR_ThreadMutex.h	/^class YR_ThreadRecMutex$/;"	c	namespace:youren
YR_TimeProvider	YR_TimeProvider.h	/^    YR_TimeProvider() : _terminate(false),_use_tsc(true), _cpu_cycle(0),_buf_idx(0){$/;"	f	class:youren::YR_TimeProvider
YR_TimeProvider	YR_TimeProvider.h	/^class YR_TimeProvider : public YR_Thread, public YR_HandleBase$/;"	c	namespace:youren
YR_TimeProviderPtr	YR_TimeProvider.h	/^    typedef YR_AutoPtr<YR_TimeProvider> YR_TimeProviderPtr;$/;"	t	class:youren::YR_TimeProvider
YR_TryLock	YR_Lock.h	/^    YR_TryLock(const T& mutex) : YR_LockT<T>(mutex, true){}$/;"	f	class:youren::YR_TryLock
YR_TryLock	YR_Lock.h	/^class YR_TryLock : public YR_LockT<T>$/;"	c	namespace:youren
_acquired	YR_Lock.h	/^    mutable bool _acquired;$/;"	m	class:youren::YR_LockT
_acquired	YR_Lock.h	/^    mutable bool _acquired;$/;"	m	class:youren::YR_RW_RLockT
_atomic	YR_AutoPtr.h	/^    atomic_type _atomic;$/;"	m	class:youren::YR_HandleBaseT
_bNoDelete	YR_AutoPtr.h	/^    bool _bNoDelete;$/;"	m	class:youren::YR_HandleBaseT
_buf_idx	YR_TimeProvider.h	/^    volatile int _buf_idx;$/;"	m	class:youren::YR_TimeProvider
_cond	YR_Monitor.h	/^    mutable P _cond;$/;"	m	class:youren::YR_Monitor
_cond	YR_ThreadCond.h	/^    mutable pthread_cond_t _cond;$/;"	m	class:youren::YR_ThreadCond
_count	YR_ThreadMutex.h	/^    mutable int _count;$/;"	m	class:youren::YR_ThreadRecMutex
_cpu_cycle	YR_TimeProvider.h	/^    float _cpu_cycle;$/;"	m	class:youren::YR_TimeProvider
_lock	YR_Thread.h	/^    YR_ThreadLock _lock;$/;"	m	class:youren::YR_Thread
_mutex	YR_Lock.h	/^    const T& _mutex;$/;"	m	class:youren::YR_LockT
_mutex	YR_Monitor.h	/^    T _mutex;$/;"	m	class:youren::YR_Monitor
_mutex	YR_ThreadMutex.h	/^    mutable pthread_mutex_t _mutex;$/;"	m	class:youren::YR_ThreadMutex
_mutex	YR_ThreadMutex.h	/^    mutable pthread_mutex_t _mutex;$/;"	m	class:youren::YR_ThreadRecMutex
_nnotify	YR_Monitor.h	/^    mutable int _nnotify;$/;"	m	class:youren::YR_Monitor
_ptr	YR_AutoPtr.h	/^    T* _ptr;$/;"	m	class:youren::YR_AutoPtr
_running	YR_Thread.h	/^    bool _running;$/;"	m	class:youren::YR_Thread
_rwLock	YR_Lock.h	/^    const T& _rwLock;$/;"	m	class:youren::YR_RW_RLockT
_t	YR_TimeProvider.h	/^    timeval _t[2];$/;"	m	class:youren::YR_TimeProvider
_terminate	YR_TimeProvider.h	/^    bool _terminate;$/;"	m	class:youren::YR_TimeProvider
_thread	YR_Thread.h	/^    pthread_t _thread;$/;"	m	class:youren::YR_ThreadControl
_tid	YR_Thread.h	/^    pthread_t _tid;$/;"	m	class:youren::YR_Thread
_tsc	YR_TimeProvider.h	/^    uint64_t _tsc[2];$/;"	m	class:youren::YR_TimeProvider
_use_tsc	YR_TimeProvider.h	/^    bool _use_tsc;$/;"	m	class:youren::YR_TimeProvider
_value	YR_Atomic.h	/^    youren_atomic_t _value;$/;"	m	class:youren::YR_Atomic
acquire	YR_Lock.h	/^    void acquire() const $/;"	f	class:youren::YR_LockT
acquired	YR_Lock.h	/^    bool acquired() const$/;"	f	class:youren::YR_LockT
add	YR_Atomic.h	/^    atomic_type add(atomic_type i) { return add_and_return(i); }$/;"	f	class:youren::YR_Atomic
add_and_return	YR_Atomic.h	/^    int add_and_return(int i)$/;"	f	class:youren::YR_Atomic
atomic_type	YR_Atomic.h	/^    typedef int atomic_type;$/;"	t	class:youren::YR_Atomic
atomic_type	YR_AutoPtr.h	/^    typedef T atomic_type;$/;"	t	class:youren::YR_HandleBaseT
count	YR_ThreadMutex.cpp	/^int YR_ThreadMutex::count() const$/;"	f	class:youren::YR_ThreadMutex
count	YR_ThreadMutex.cpp	/^int YR_ThreadRecMutex::count() const$/;"	f	class:youren::YR_ThreadRecMutex
count	YR_ThreadMutex.cpp	/^void YR_ThreadMutex::count(int c) const$/;"	f	class:youren::YR_ThreadMutex
count	YR_ThreadMutex.cpp	/^void YR_ThreadRecMutex::count(int c) const$/;"	f	class:youren::YR_ThreadRecMutex
counter	YR_Atomic.h	/^    typedef struct { volatile int counter; } youren_atomic_t;$/;"	m	struct:youren::__anon1
dec	YR_Atomic.h	/^    atomic_type dec() { return sub(1); }$/;"	f	class:youren::YR_Atomic
decRef	YR_AutoPtr.h	/^    void decRef()$/;"	f	class:youren::YR_HandleBaseT
decRef	YR_AutoPtr.h	/^inline void YR_HandleBaseT<int>::decRef()$/;"	f	class:youren::YR_HandleBaseT
dec_and_test	YR_Atomic.h	/^    bool dec_and_test()$/;"	f	class:youren::YR_Atomic
detach	YR_Thread.cpp	/^void YR_ThreadControl::detach()$/;"	f	class:youren::YR_ThreadControl
dynamicCast	YR_AutoPtr.h	/^    static YR_AutoPtr dynamicCast(Y* p)$/;"	f	class:youren::YR_AutoPtr
dynamicCast	YR_AutoPtr.h	/^    static YR_AutoPtr dynamicCast(const YR_AutoPtr<Y> & r)$/;"	f	class:youren::YR_AutoPtr
element_type	YR_AutoPtr.h	/^    typedef T element_type;$/;"	t	class:youren::YR_AutoPtr
g_tl	YR_TimeProvider.cpp	/^YR_ThreadLock YR_TimeProvider::g_tl;$/;"	m	class:youren::YR_TimeProvider	file:
g_tl	YR_TimeProvider.h	/^    static YR_ThreadLock g_tl;$/;"	m	class:youren::YR_TimeProvider
g_tp	YR_TimeProvider.cpp	/^YR_TimeProvider::YR_TimeProviderPtr YR_TimeProvider::g_tp = NULL;$/;"	m	class:youren::YR_TimeProvider	file:
g_tp	YR_TimeProvider.h	/^    static YR_TimeProviderPtr g_tp;$/;"	m	class:youren::YR_TimeProvider
get	YR_Atomic.h	/^    atomic_type get() const { return _value.counter; }$/;"	f	class:youren::YR_Atomic
get	YR_AutoPtr.h	/^    T* get() const$/;"	f	class:youren::YR_AutoPtr
getInstance	YR_TimeProvider.cpp	/^YR_TimeProvider* YR_TimeProvider::getInstance()$/;"	f	class:youren::YR_TimeProvider
getNow	YR_TimeProvider.h	/^    time_t getNow() { return _t[_buf_idx].tv_sec; }$/;"	f	class:youren::YR_TimeProvider
getRef	YR_AutoPtr.h	/^    int getRef() const { return _atomic.get(); }$/;"	f	class:youren::YR_HandleBaseT
getRef	YR_AutoPtr.h	/^inline int YR_HandleBaseT<int>::getRef() const$/;"	f	class:youren::YR_HandleBaseT
getThreadControl	YR_Thread.cpp	/^YR_ThreadControl YR_Thread::getThreadControl() const$/;"	f	class:youren::YR_Thread
id	YR_Thread.cpp	/^pthread_t YR_ThreadControl::id() const$/;"	f	class:youren::YR_ThreadControl
id	YR_Thread.h	/^    pthread_t id() { return _tid; }$/;"	f	class:youren::YR_Thread
inc	YR_Atomic.h	/^    atomic_type inc() { return add(1); }$/;"	f	class:youren::YR_Atomic
incRef	YR_AutoPtr.h	/^    void incRef() {_atomic.inc_fase();}$/;"	f	class:youren::YR_HandleBaseT
incRef	YR_AutoPtr.h	/^inline void YR_HandleBaseT<int>::incRef()$/;"	f	class:youren::YR_HandleBaseT
inc_fast	YR_Atomic.h	/^    void inc_fast()$/;"	f	class:youren::YR_Atomic
isAlive	YR_Thread.cpp	/^bool YR_Thread::isAlive() const $/;"	f	class:youren::YR_Thread
join	YR_Thread.cpp	/^void YR_ThreadControl::join()$/;"	f	class:youren::YR_ThreadControl
lock	YR_Lock.h	/^    int lock() const { return 0; }$/;"	f	class:youren::YR_EmptyMutex
lock	YR_Monitor.h	/^    void lock() const$/;"	f	class:youren::YR_Monitor
lock	YR_ThreadMutex.cpp	/^int YR_ThreadRecMutex::lock() const$/;"	f	class:youren::YR_ThreadRecMutex
lock	YR_ThreadMutex.cpp	/^void YR_ThreadMutex::lock() const$/;"	f	class:youren::YR_ThreadMutex
notify	YR_Monitor.h	/^    void notify()$/;"	f	class:youren::YR_Monitor
notifyAll	YR_Monitor.h	/^    void notifyAll()$/;"	f	class:youren::YR_Monitor
notifyImpl	YR_Monitor.h	/^    void notifyImpl(int nnotify) const$/;"	f	class:youren::YR_Monitor
operator !=	YR_AutoPtr.h	/^operator!=(const YR_AutoPtr<T>& lhs, const YR_AutoPtr<U>& rhs)$/;"	f	namespace:youren
operator *	YR_AutoPtr.h	/^    T& operator*() const$/;"	f	class:youren::YR_AutoPtr
operator ++	YR_Atomic.h	/^    YR_Atomic& operator++()$/;"	f	class:youren::YR_Atomic
operator +=	YR_Atomic.h	/^    YR_Atomic& operator+=(atomic_type n)$/;"	f	class:youren::YR_Atomic
operator --	YR_Atomic.h	/^    YR_Atomic& operator--()$/;"	f	class:youren::YR_Atomic
operator -=	YR_Atomic.h	/^    YR_Atomic& operator-=(atomic_type n)$/;"	f	class:youren::YR_Atomic
operator ->	YR_AutoPtr.h	/^    T* operator->() const$/;"	f	class:youren::YR_AutoPtr
operator <	YR_AutoPtr.h	/^operator<(const YR_AutoPtr<T>& lhs,const YR_AutoPtr<U>& rhs)$/;"	f	namespace:youren
operator =	YR_Atomic.h	/^    YR_Atomic& operator=(atomic_type n)$/;"	f	class:youren::YR_Atomic
operator =	YR_AutoPtr.h	/^    YR_AutoPtr& operator=(T* p)$/;"	f	class:youren::YR_AutoPtr
operator =	YR_AutoPtr.h	/^    YR_AutoPtr& operator=(const YR_AutoPtr& r)$/;"	f	class:youren::YR_AutoPtr
operator =	YR_AutoPtr.h	/^    YR_AutoPtr& operator=(const YR_AutoPtr<Y>& r)$/;"	f	class:youren::YR_AutoPtr
operator =	YR_AutoPtr.h	/^    YR_HandleBaseT& operator=(const YR_HandleBaseT&) { return *this; }$/;"	f	class:youren::YR_HandleBaseT
operator ==	YR_AutoPtr.h	/^operator==(const YR_AutoPtr<T>& lhs, const YR_AutoPtr<U>& rhs)$/;"	f	namespace:youren
operator atomic_type	YR_Atomic.h	/^    operator atomic_type() const $/;"	f	class:youren::YR_Atomic
operator bool	YR_AutoPtr.h	/^    operator bool() const$/;"	f	class:youren::YR_AutoPtr
rdtsc	YR_TimeProvider.h	7;"	d
release	YR_Lock.h	/^    void release() const$/;"	f	class:youren::YR_LockT
set	YR_Atomic.h	/^    atomic_type set(atomic_type i)$/;"	f	class:youren::YR_Atomic
setNoDelete	YR_AutoPtr.h	/^    void setNoDelete(bool b) { _bNoDelete = b; }$/;"	f	class:youren::YR_HandleBaseT
sleep	YR_Thread.cpp	/^void YR_ThreadControl::sleep(long millsecond) $/;"	f	class:youren::YR_ThreadControl
start	YR_Thread.cpp	/^YR_ThreadControl YR_Thread::start()$/;"	f	class:youren::YR_Thread
sub	YR_Atomic.h	/^    atomic_type sub(atomic_type i) { return add_and_return(-i); }$/;"	f	class:youren::YR_Atomic
swap	YR_AutoPtr.h	/^    void swap(YR_AutoPtr& other)$/;"	f	class:youren::YR_AutoPtr
threadEntry	YR_Thread.cpp	/^void YR_Thread::threadEntry(YR_Thread* pThread)$/;"	f	class:youren::YR_Thread
throwNullHandleException	YR_AutoPtr.h	/^YR_AutoPtr<T>::throwNullHandleException() const$/;"	f	class:youren::YR_AutoPtr
timeWait	YR_Monitor.h	/^    bool timeWait(int millsecond) const$/;"	f	class:youren::YR_Monitor
timewait	YR_ThreadCond.h	/^    bool timewait(const Mutex& mutex, int millsecond) const$/;"	f	class:youren::YR_ThreadCond
tryAcquired	YR_Lock.h	/^    bool tryAcquired() const$/;"	f	class:youren::YR_LockT
tryLock	YR_Monitor.h	/^    bool tryLock() const $/;"	f	class:youren::YR_Monitor
tryLock	YR_ThreadMutex.cpp	/^bool YR_ThreadMutex::tryLock() const$/;"	f	class:youren::YR_ThreadMutex
tryLock	YR_ThreadMutex.cpp	/^bool YR_ThreadRecMutex::tryLock() const$/;"	f	class:youren::YR_ThreadRecMutex
trylock	YR_Lock.h	/^    bool trylock() const { return true; }$/;"	f	class:youren::YR_EmptyMutex
unlock	YR_Lock.h	/^    int unlock() const { return 0; }$/;"	f	class:youren::YR_EmptyMutex
unlock	YR_Monitor.h	/^    void unlock() const$/;"	f	class:youren::YR_Monitor
unlock	YR_ThreadMutex.cpp	/^int YR_ThreadRecMutex::unlock() const$/;"	f	class:youren::YR_ThreadRecMutex
unlock	YR_ThreadMutex.cpp	/^void YR_ThreadMutex::unlock() const$/;"	f	class:youren::YR_ThreadMutex
wait	YR_Monitor.h	/^    void wait() const$/;"	f	class:youren::YR_Monitor
wait	YR_ThreadCond.h	/^    void wait(const Mutex& mutex) const$/;"	f	class:youren::YR_ThreadCond
willUnlock	YR_ThreadMutex.cpp	/^bool YR_ThreadRecMutex::willUnlock() const$/;"	f	class:youren::YR_ThreadRecMutex
willUnlock	YR_ThreadMutex.h	/^    bool willUnlock() const { return true; }$/;"	f	class:youren::YR_ThreadMutex
yield	YR_Thread.cpp	/^void YR_ThreadControl::yield()$/;"	f	class:youren::YR_ThreadControl
youren	YR_Atomic.h	/^namespace youren {$/;"	n
youren	YR_AutoPtr.h	/^namespace youren{$/;"	n
youren	YR_Lock.h	/^namespace youren {$/;"	n
youren	YR_Monitor.h	/^namespace youren {$/;"	n
youren	YR_Thread.cpp	/^namespace youren{$/;"	n	file:
youren	YR_Thread.h	/^namespace youren {$/;"	n
youren	YR_ThreadCond.h	/^namespace youren {$/;"	n
youren	YR_ThreadMutex.cpp	/^namespace youren{$/;"	n	file:
youren	YR_ThreadMutex.h	/^namespace youren {$/;"	n
youren	YR_TimeProvider.cpp	/^namespace youren {$/;"	n	file:
youren	YR_TimeProvider.h	/^namespace youren {$/;"	n
youren_atomic_read	YR_Atomic.h	11;"	d
youren_atomic_set	YR_Atomic.h	13;"	d
youren_atomic_t	YR_Atomic.h	/^    typedef struct { volatile int counter; } youren_atomic_t;$/;"	t	namespace:youren	typeref:struct:youren::__anon1
~YR_Atomic	YR_Atomic.h	/^    ~YR_Atomic() {}$/;"	f	class:youren::YR_Atomic
~YR_AutoPtr	YR_AutoPtr.h	/^    ~YR_AutoPtr() {$/;"	f	class:youren::YR_AutoPtr
~YR_AutoPtrNull_Exception	YR_AutoPtr.h	/^    ~YR_AutoPtrNull_Exception() throw(){}$/;"	f	struct:youren::YR_AutoPtrNull_Exception
~YR_HandleBaseT	YR_AutoPtr.h	/^    virtual ~YR_HandleBaseT(){}$/;"	f	class:youren::YR_HandleBaseT
~YR_LockT	YR_Lock.h	/^    virtual ~YR_LockT() {$/;"	f	class:youren::YR_LockT
~YR_Lock_Exception	YR_Lock.h	/^    ~YR_Lock_Exception() throw(){  }$/;"	f	struct:youren::YR_Lock_Exception
~YR_Monitor	YR_Monitor.h	/^    virtual ~YR_Monitor() {}$/;"	f	class:youren::YR_Monitor
~YR_RW_RLockT	YR_Lock.h	/^    ~YR_RW_RLockT()$/;"	f	class:youren::YR_RW_RLockT
~YR_Runable	YR_Thread.h	/^    virtual ~YR_Runable(){}$/;"	f	class:youren::YR_Runable
~YR_Thread	YR_Thread.h	/^    virtual ~YR_Thread() {}$/;"	f	class:youren::YR_Thread
~YR_ThreadCond	YR_ThreadCond.h	/^    ~YR_ThreadCond() {}$/;"	f	class:youren::YR_ThreadCond
~YR_ThreadCond_Exception	YR_ThreadCond.h	/^    ~YR_ThreadCond_Exception() throw(){}$/;"	f	struct:youren::YR_ThreadCond_Exception
~YR_ThreadControl_Exception	YR_Thread.h	/^    ~YR_ThreadControl_Exception() throw() {}$/;"	f	struct:youren::YR_ThreadControl_Exception
~YR_ThreadMutex	YR_ThreadMutex.cpp	/^YR_ThreadMutex::~YR_ThreadMutex()$/;"	f	class:youren::YR_ThreadMutex
~YR_ThreadMutex	YR_ThreadMutex.h	/^    virtual ~YR_ThreadMutex() {}$/;"	f	class:youren::YR_ThreadMutex
~YR_ThreadMutex_Exception	YR_ThreadMutex.h	/^    ~YR_ThreadMutex_Exception() throw(){}$/;"	f	struct:youren::YR_ThreadMutex_Exception
~YR_ThreadRecMutex	YR_ThreadMutex.cpp	/^YR_ThreadRecMutex::~YR_ThreadRecMutex()$/;"	f	class:youren::YR_ThreadRecMutex
